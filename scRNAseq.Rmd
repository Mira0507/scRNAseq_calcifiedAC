---
output: html_document
title: "scRNA-seq Analysis of Calcified Atherosclerotic Plaque "
author: "Mira Sohn" 
---

## Raw data 

#### - **Stuby number**: [GSE159677](Link: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE159677)

#### - **Study summary**: Neurological complications are common in patients with COVID-19. While SARS-CoV-2, the causal pathogen of COVID-19, has been detected in some patient brains, its ability to infect brain cells and impact their function are not well understood, and experimental models using human brain cells are urgently needed. Here we investigated the susceptibility of human induced pluripotent stem cell (hiPSC)-derived monolayer brain cells and region-specific brain organoids to SARS-CoV-2 infection. We found modest numbers of infected neurons and astrocytes, but greater infection of choroid plexus epithelial cells. We optimized a protocol to generate choroid plexus organoids from hiPSCs, which revealed productive SARS-CoV-2 infection that leads to increased cell death and transcriptional dysregulation indicative of an inflammatory response and cellular function deficits. Together, our results provide evidence for SARS-CoV-2 neurotropism and support use of hiPSC-derived brain organoids as a platform to investigate the cellular susceptibility, disease mechanisms, and treatment strategies for SARS-CoV-2 infection. Bulk RNA-seq of choroid plexus organoids (CPOs) was performed on mock 72 hours post-infection (hpi), SARS-CoV-2 24 hpi, and SARS-CoV-2 72 hpi samples. All conditions were profiled in triplicate.

#### - **Method**: Calcified atherosclerotic core (AC) plaques and patient-matched proximal adjacent (PA) portions of carotid artery were collected from three patients undergoing carotid endarterectomy and were assessed using single cell RNA-seq.

#### - **Data**: Supplementary file -> GSE159677_AGGREGATEMAPPED-tisCAR6samples_featurebcmatrixfiltered.tar.gz -> barcodes.tsv.gz, feature.tsvgz, matrix.mtx.gz 

```{r global_options, include=FALSE}


knitr::opts_chunk$set(
    warning=FALSE,
    message=FALSE
    )


```

## Loading packages 

```{r loading_packages}
library(Matrix)
library(tidyverse)
library(ggplot2)
library(data.table)
library(Seurat)
library(AnnotationHub)
library(cowplot)
library(ensembldb)
```


## Loading matrices into R

#### - Tutorial: [10X Genomics](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/matrices), [HBC training I](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/03_SC_quality_control-setup.md), [HBC training II](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/readMM_loadData.md)

#### - Package manual: [Matrix](https://cran.r-project.org/web/packages/Matrix/Matrix.pdf)

#### - Read10X() from Seurat package can be used when loading count matrices instead of manual loading. See [HBC training I](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/03_SC_quality_control-setup.md) for more info.

```{r loading_matrix}
# Assign your file paths
barcode.path <- "barcodes.tsv.gz"   # cell ids
features.path <- "features.tsv.gz"  # gene ids
matrix.path <- "matrix.mtx.gz"      # counts

# Import the files
# readMM() turns into a sparse matrix (which only stores non-zero values) 
# in order to minimize data size
mat <- readMM(file=matrix.path) 

feature.names <- read.delim(features.path, 
                            header=FALSE, 
                            stringsAsFactors=FALSE)
barcode.names <- read.delim(barcode.path,
                            header=FALSE,
                            stringsAsFactors=FALSE)


# Assign row/column names
colnames(mat) <- barcode.names$V1
rownames(mat) <- feature.names$V1



```

## Creating a seurat object from the count matrix

#### - Seurat manual: [manual](https://cran.r-project.org/web/packages/Seurat/Seurat.pdf), [Satija Lab](https://satijalab.org/seurat)

#### - Tutorial reference: [HBC training](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/03_SC_quality_control-setup.md)

#### - "min.features" parameter in CreateSeuratObject() function specifies the minimum number of genes that need to be detected per cell. This argument will filter out poor quality cells that likely just have random barcodes encapsulated without any cell present. Usually, cells with less than 100 genes detected are not considered for analysis. 

#### - CreateSeuratObject() automatically creates metadata as well 

#### - Metadata in the seurat object: orig.ident (this often contains the sample identity if known, but will default to "SeuratProject"), nCount_RNA (number of UNIs per cell), nFeature_RNA (number of genes detected per cell)

```{r create_seurat}

# Create a seurat object 
seurat <- CreateSeuratObject(counts=mat,    # accepts a sparse matrix 
                             min.features=100) # see above note 

# Explore the metadata (see above description)  
head(seurat@meta.data)




# In case you have multiple samples to create a seurat object: 
# 
# for (file in c("ctrl_raw_feature_bc_matrix", "stim_raw_feature_bc_matrix")){
# 
#         seurat_data <- Read10X(data.dir = paste0("data/", file))
#         seurat_obj <- CreateSeuratObject(counts = seurat_data, 
#                                          min.features = 100, 
#                                          project = file)
#         assign(file, seurat_obj)
# }
# 
# Create a merged Seurat object
# merged_seurat <- merge(x = ctrl_raw_feature_bc_matrix, 
#                        y = stim_raw_feature_bc_matrix, 
#                        add.cell.id = c("ctrl", "stim"))
# Check that the merged object has the appropriate sample-specific prefixes
# head(merged_seurat@meta.data)
# tail(merged_seurat@meta.data)

```

## Quality control (QC)

#### - Tutorial: [HBC training](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/04_SC_quality_control.md)

#### - Seurat provides functions for QC shown in this script. For manual QC, consult [this instruction](https://hbctraining.github.io/In-depth-NGS-Data-Analysis-Course/sessionIV/lessons/SC_quality_control_analysis.html)

#### - QC metrics: cell counts, UMI counts per cell, genes detected per cell, UMIs vs genes detected, mitochondrial counts ratio, novelty



### QC: calculating number of genes detected per UMI 

```{r genes_per_UMI}

# Add number of genes per UMI for each cell to metadata
seurat$log10GenesPerUMI <- log10(seurat$nFeature_RNA) / log10(seurat$nCount_RNA)

# Explore the updated metadata
head(seurat@meta.data)
```


### QC: calculating mitochondrial ratio

#### - Proportion of transcripts mapping to mitochondrial genes

#### - Mitochondrial read fractions are only high in particularly low count cells with few detected genes (darker colored data points). This could be indicative of damaged/dying cells whose cytoplasmic mRNA has leaked out through a broken membrane, and thus, only mRNA located in the mitochondria is still conserved.

#### - PercentageFeatureSet() from seurat package searches for any gene identifiers with the patter argument (e.g. "MT-") 

#### - You can manually calculate by following [this tutorial](https://github.com/hbctraining/scRNA-seq/blob/master/lessons/mitoRatio.md) from HBC training in case you can't use the seurat built-in function  

```{r mitochondrial_ratio}

# Compute percent mito ratio
# NOTE: "^MT-" is for human genes. Adjust it depending on your organism of interest.
# Calculate manually as instructed above if you don't have available identifier patterns
seurat$mitoRatio <- PercentageFeatureSet(object=seurat, 
                                         pattern="^MT-")

# Convert the ratio to percentage 
seurat$mitoRatio <- seurat@meta.data$mitoRatio / 100

# Explore the updated metadata
head(seurat@meta.data)

```


### Adding more info to the metadata 

```{r adding_more_info}

# Create a dataframe from the metadata
meta <- seurat@meta.data

# Add cell ids to the data frame
meta$cells <- rownames(meta)

meta <- meta %>% 
    separate(cells, c("Barcode", "Sample"), sep="-")

# Rename some of the columns 
old.colnames <- colnames(meta)
colnames(meta) <- c("seq.folder", "nUMI", "nGene", 
                    old.colnames[4:length(old.colnames)])

# Explore the updated data frame
head(meta)

# Update the seurat object with the updated metadata
seurat@meta.data <- meta

# Explore the updated metadata
head(seurat@meta.data)


```


### QC: plotting cell counts

#### - cell counts: number of unique barcodes detected 

#### - In theory, the cell counts correspond to the number of cells loaded. However,  it generally ends up being 50-80% of total cells loaded due to capture effieciency which is 70-80% in inDrops and 50-60% in 10X


```{r number_of_cells}

# Plot the number of cells per sample
ggplot(meta, aes(x=Sample, fill=Sample)) + 
    geom_bar() + 
    theme_bw() + 
    ggtitle("QC: Number of Cells per Sample") + 
    ylab("Number")


```

### QC: plotting UMI counts (transcripts) per cell

#### - UMI counts per cell should be above 500 (denoted by the black dashed line)


```{r umi_per_cell}

# Plot the number of transcripts per cell
ggplot(meta, aes(x=nUMI, fill=Sample, color=Sample)) + 
    geom_density(alpha=0.2) + 
    scale_x_log10() + 
    theme_bw() +
    ggtitle("QC: UMI Counts (Transcripts) per Cell") + 
    ylab("log10 Cell Density") + 
    geom_vline(xintercept=500, linetype="dashed")



```


### QC: number of genes detected per cell

#### - A single large peak: high quality data

#### - Peaks with shoulders or bimodal distribution: failed cells, biologically different types of cells (e.g. quiescent cells, low complexity cells like RBC, etc), and/or variety in cell size

```{r number_of_genes_per_cell}

# Plot the number of genes detected per cell
ggplot(meta, aes(x=nGene, color=Sample, fill=Sample)) + 
    geom_density(alpha=0.2) + 
    scale_x_log10() + 
    theme_bw() +
    ylab("log10 Cell Density") + 
    ggtitle("QC: Number of Genes Detected per Cell") + 
    geom_vline(xintercept=300, linetype="dashed")


ggplot(meta, aes(x=Sample, y=nGene, fill=Sample)) + 
    geom_boxplot(outlier.alpha=0.5) + 
    theme_bw() + 
    scale_y_log10() + 
    ylab("log10 Number of Genes") + 
    ggtitle("QC: NCells vs NGenes")

```


### QC: nUMIs vs nGenes per cell  

#### - Mitochondrial read fractions are only high in particularly low count cells with few detected genes (darker colored data points). This could be indicative of damaged/dying cells whose cytoplasmic mRNA has leaked out through a broken membrane, and thus, only mRNA located in the mitochondria is still conserved. These cells are filtered out by our count and gene number thresholds. Jointly visualizing the count and gene thresholds shows the joint filtering effect

#### - Cells that are poor quality are likely to have low genes and UMIs per cell, and correspond to the data points in the bottom left quadrant of the plot. Good cells will generally exhibit both higher number of genes per cell and higher numbers of UMIs

#### - With this plot we also evaluate the slope of the line, and any scatter of data points in the bottom right hand quadrant of the plot. These cells have a high number of UMIs but only a few number of genes. These could be dying cells, but also could represent a population of a low complexity celltype (i.e red blood cells)


```{r nUMI_nGenes, fig.width=12, fig.height=8}

# Plot nUMIs vs nGenes per cell along with mitoRatio
ggplot(meta, aes(x=nUMI, y=nGene, color=mitoRatio)) + 
    geom_point(alpha=0.5) + 
    scale_color_gradient(low="gray90", high="black") + 
    geom_smooth(method="lm", color="blue", se=F) +
    facet_grid(~Sample) + 
    theme_bw() + 
    theme(strip.text.x=element_text(size=10)) + 
    geom_vline(xintercept=500, color="red") + 
    geom_hline(yintercept=250, color="red") + 
    xlab("Number of UMIs per Cell") + 
    ylab("Number of Genes per Cell") + 
    ggtitle("Number of UMIs vs Genes per Cell")

```


### QC: mitochondrial counts ratio 

#### - Mitochondrial contamination is observed in dead or dying cells 

#### - **mitoRatio > 0.2** suggests poor quality 


```{r mitochondrial_contamination}

# Plot proportion of mitochondrial counts 
ggplot(meta, aes(x=mitoRatio, color=Sample, fill=Sample)) + 
    geom_density(alpha=0.2) + 
    theme_bw() + 
    scale_x_log10() + 
    geom_vline(xintercept=0.2) + 
    xlab("Proportion of Mitochondrial Counts Detected") + 
    ylab("Cell Density") + 
    ggtitle("QC: Proportion of Mitochondrial Counts")

```


### QC: complexity

#### - Novelty score: gene diversity per UMI

#### - Ideal **novelty score: > 0.8**

#### - Sometimes we can detect contamination with low complexity cell types like red blood cells via this metric


```{r novelty}

# Plot the overall complexity of the gene expression by visualizing the genes detected per UMI
ggplot(meta, aes(x=log10GenesPerUMI, color=Sample, fill=Sample)) + 
    geom_density(alpha=0.2) + 
    theme_bw() + 
    geom_vline(xintercept=0.8, linetype="dashed") + 
    ggtitle("QC: Complexity of Gene Expression") + 
    ylab("log10 Cell Density")

```


### QC: cell-level filtering

#### - Removes low quality cells 

#### - Thresholds: **nUMI >= 500, nGene >= 250, log10GenesPerUMI >= 0.8, mitoRatio (%) <= 0.2**

#### - Will use subset() function

```{r cell_level_filtering}

# Filter out low quality cells 
f.seurat <- subset(x=seurat, 
                   subset=(nUMI >= 500) & 
                       (nGene >= 250) & 
                       (log10GenesPerUMI > 0.8) & 
                       (mitoRatio < 0.2))

# Compare seurat objects before and after cell-level filtering
seurat     # Before filtering 
f.seurat   # After cell-level filtering
```

### QC: gene-level filtering

#### - Removes low count genes


```{r gene_level_filtering}

# Assign the minimum counts (User-defined!)
count.threshold <- 10

# Extract counts (turns into a parse matrix)
counts <- GetAssayData(object=f.seurat, slot="counts")

# Create a logical matrix identifying non-zero count genes
nonzero <- counts > 0

# Create a logical vector identifying genes with counts over threshold
keep <- rowSums(nonzero) >= count.threshold

# Filter genes with the logical vector 
counts <- counts[keep,]

# Create a new seurat object with the filtered count matrix 
f.seurat <- CreateSeuratObject(counts, 
                               meta.data=f.seurat@meta.data)


# Compare the seurat objects before and after filtering
seurat     # Before filtering
f.seurat   # After cell- and gene-level filtering

```

### QC: QC metrics after filtering


```{r QC_after_filtering, fig.height=8, fig.width=12}

# Extract metadata after filtering
new.meta <- f.seurat@meta.data

# Add a column assigning before or after filtering
meta$Filtering <- "Before Filtering"
new.meta$Filtering <- "After Filtering"

# Remove duplicated columns
new.meta <- new.meta[, colnames(new.meta) %in% colnames(meta)]

# Combine the metadata before and after filtering
both.meta <- rbind(meta, new.meta)

both.meta$Filtering <- factor(both.meta$Filtering, 
                              levels=c("Before Filtering", "After Filtering"))

# Create a bar plot comparing number of cells per sample before and after filtering
ggplot(both.meta, aes(x=Sample, fill=Sample)) + 
    geom_bar() + 
    facet_grid(~Filtering) +
    theme_bw() + 
    theme(strip.text.x=element_text(size=10)) + 
    ggtitle("QC: Number of Cells per Sample (before & after Filtering)") + 
    ylab("Number") 


# Plot the number of transcripts per cell before and after filtering
ggplot(both.meta, aes(x=nUMI, fill=Sample, color=Sample)) + 
    geom_density(alpha=0.2) + 
    scale_x_log10() + 
    theme_bw() +
    facet_grid(~Filtering) + 
    theme(strip.text.x=element_text(size=10)) + 
    ggtitle("QC: UMI Counts (Transcripts) per Cell (before & after Filtering)") + 
    ylab("log10 Cell Density") + 
    geom_vline(xintercept=500, linetype="dashed")


# Plot the number of genes detected per cell before and after filtering
# Density plot
ggplot(both.meta, aes(x=nGene, color=Sample, fill=Sample)) + 
    geom_density(alpha=0.2) + 
    scale_x_log10() + 
    theme_bw() +
    facet_grid(~Filtering) + 
    theme(strip.text.x=element_text(size=10)) + 
    ylab("log10 Cell Density") + 
    ggtitle("QC: Number of Genes Detected per Cell (before & after Filtering)") + 
    geom_vline(xintercept=300, linetype="dashed")

# Box plot
ggplot(both.meta, aes(x=Sample, y=nGene, fill=Sample)) + 
    geom_boxplot(outlier.alpha=0.5) + 
    theme_bw() + 
    facet_grid(~Filtering) + 
    theme(strip.text.x=element_text(size=10)) + 
    scale_y_log10() + 
    ylab("log10 Number of Genes") + 
    ggtitle("QC: NCells vs NGenes (before and after Filtering)")


# Plot nUMIs vs nGenes per cell along with mitoRatio (before and after filtering)
ggplot(both.meta, aes(x=nUMI, y=nGene, color=mitoRatio)) + 
    geom_point(alpha=0.5) + 
    scale_color_gradient(low="gray90", high="black") + 
    geom_smooth(method="lm", color="blue", se=F) +
    facet_grid(Filtering~Sample) + 
    theme_bw() + 
    theme(strip.text=element_text(size=10)) + 
    geom_vline(xintercept=500, color="red") + 
    geom_hline(yintercept=250, color="red") + 
    xlab("Number of UMIs per Cell") + 
    ylab("Number of Genes per Cell") + 
    ggtitle("Number of UMIs vs Genes per Cell (before & after Filtering)")

# NOTE: Given the fact that this raw data already had mitoRatio close to 0, mitoRatio comparison is skipped

# Plot the overall complexity of the gene expression by visualizing the genes detected per UMI (before and after filtering)
ggplot(both.meta, aes(x=log10GenesPerUMI, color=Sample, fill=Sample)) + 
    geom_density(alpha=0.2) + 
    theme_bw() + 
    facet_grid(~Filtering) + 
    theme(strip.text.x=element_text(size=10)) + 
    geom_vline(xintercept=0.8, linetype="dashed") + 
    ggtitle("QC: Complexity of Gene Expression (before and after Filtering)") + 
    ylab("log10 Cell Density")
```




## Investigation of unwanted variations and Normalization

#### - Reference: [HBC training I](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/05_normalization_and_PCA.md), [HBC training II](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/06_SC_SCT_normalization.md), [HBC training III](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/cell_cycle_scoring.md), [Seurat "Cell-cycle scoring and regression"](https://satijalab.org/seurat/v3.0/cell_cycle_vignette.html)

#### - Factors being normalized: sequencing depth, gene length 

#### - Identifies the most variant genes

#### - Requires users to know cell types to be present (e.g. low complexity? higher mitochondrial contents? differentiating cells? etc) and to regress out nUMIs, mitochondrial content, and cell cycle if needed 

#### - Seurat provides **sctransform** which simultaneously performs variance stabilization and regresses out unwanted variation 

#### - Roughly normalizes by dividing by total counts per cell and taking the natural log 

#### - Simple linear regression will be performed to correct data after finding the unwanted variation



### Unwanted variation: cell cycle 

#### - **Human cell cycle markers** used in this analysis was obtained from [one](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/06_SC_SCT_normalization.md) of the HBC training courses. If you need the cell cycle markers from other species, check [this](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/cell_cycle_scoring.md) out

#### -  


```{r importing_cellcycle_genes}

# NOTE: This chunk has to be written by users!!! 
#
#
#
# Import a dataset storing cell cycle genes
cc.genes <- read_csv("https://raw.githubusercontent.com/hbc/tinyatlas/master/cell_cycle/Homo_sapiens.csv")

# Set species and DB namedb
organism <- "Homo sapiens"
DB <- "EnsDb"   # e.g. EnsDb, OrgDb, etc

```


```{r setup_annotationhub}

# Connect to AnnotationHub
ah <- AnnotationHub(hub=getAnnotationHubOption("URL"))

# Bring the Ensembl DB 
anno.db <- query(ah, 
                 pattern=c(organism, DB), 
                 ignore.case=T)

# Find the id from most recent annotation data
id <- mcols(anno.db) %>% 
    rownames() %>%
    tail(1)

# Download the most recent annotation table 
id.db <- ah[[id]]

# Extract gene-level info and save as a data frame 
gene.db <- genes(id.db, return.type="data.frame")

```

```{r sgenes_g2mgenes}

# Combine two data frames
cc.genes <- inner_join(cc.genes, gene.db, by=c("geneID"="gene_id"))

# Create a vector storing S phase genes
s.genes <- subset(cc.genes, phase=="S")$gene_name

# Create a vector storing G2M phase genes
g2m.genes <- subset(cc.genes, phase=="G2/M")$gene_name

# Explore the outputs
head(s.genes)
head(g2m.genes)

```


```{r cellcycle_test}

# Normalize the counts
ccycle.seurat <- NormalizeData(f.seurat)


# Calculate cell cycle scores using CellCycleScoreing() function
ccycle.seurat <- CellCycleScoring(ccycle.seurat, 
                                  g2m.features=g2m.genes,
                                  s.features=s.genes)

# Explore the updated metadata
head(ccycle.seurat@meta.data)

# Examine variation from cell cycle
if ("Phase" %in% colnames(ccycle.seurat@meta.data)) {


# Identify the most variable genes
ccycle.seurat <- FindVariableFeatures(ccycle.seurat,
                                      selection.method="vst",
                                      nfeatures=2000,
                                      verbose=T)

# Scale the data (to mean = 0, variance = 1)
ccycle.seurat <- ScaleData(ccycle.seurat)

# Run PCA
ccycle.seurat <- RunPCA(ccycle.seurat)

# Plot the PCA result
DimPlot(ccycle.seurat, 
        reduction="pca", 
        group.by="Phase", 
        split.by="Phase")

} else { 

    print("No cell cycle effects were found")

}


```

### Unwanted variation: mitochondrial expression

#### - NOTE: In case mitochondrial expression is involved in biological events of your interest, do not correct it


### Normalization and regressing out unwated variation with SCTransform

#### - SCTransform: more accurate method of normalizing, estimating the variance of the raw filtered data, and identifying the most variable genes 

#### - SCTransform uses a regularized negative binomial model 


```{r example_sctransform}

# Run below in case your dataset has variations to regress out
# ccycle.seurat <- SCTransform(ccycle.seurat, 
#                              vars.to.regress=c("mitoRatio"))

```


## Integration by Seurat (optional)

#### - References: [Seurat tutorial I (stim. vs ctrl)](https://satijalab.org/seurat/v3.0/immune_alignment.html), [Seurat tutorial II (cell cycle)](https://satijalab.org/seurat/v3.2/cell_cycle_vignette.html), [HBC training](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/postQC_workflow.md), [Stuart and Butler et al, 2018](https://www.biorxiv.org/content/10.1101/460147v1)



```{r}

# Split the filtered seurat object by condition
split.seurat <- SplitObject(f.seurat, split.by="Sample")


# Iterately run NormalizeData(), CellCycleScoring(), and SCTransform()
for (i in 1:length(split.seurat)) {

    split.seurat[[i]] <- NormalizeData(split.seurat[[i]], verbose=T)
    split.seurat[[i]] <- CellCycleScoring(split.seurat[[i]],
                                          g2m.features=g2m.genes,
                                          s.features=s.genes)
    split.seurat[[i]] <- STransform(split.seurat[[i]], 
                                    vars.to.regress=c("mitoRatio"))
}




```


## Session Info

```{r}

sessionInfo()

```
