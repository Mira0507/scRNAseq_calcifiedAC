---
output: html_document
title: "scRNA-seq Analysis of Calcified Atherosclerotic Plaque "
author: "Mira Sohn" 
---

## Raw data 

#### - **Stuby number**: [GSE159677](Link: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE159677)

#### - **Method**: Calcified atherosclerotic core (AC) plaques and patient-matched proximal adjacent (PA) portions of carotid artery were collected from three patients undergoing carotid endarterectomy and were assessed using single cell RNA-seq.

#### - **Data**: Supplementary file -> GSE159677_AGGREGATEMAPPED-tisCAR6samples_featurebcmatrixfiltered.tar.gz -> barcodes.tsv.gz, feature.tsvgz, matrix.mtx.gz 

```{r global_options, include=FALSE}


knitr::opts_chunk$set(
    warning=FALSE,
    message=FALSE
    )


```

## Loading packages 

```{r loading_packages}
library(Matrix)
library(tidyverse)
library(ggplot2)
library(ggrepel)
library(data.table)
library(Seurat)
library(AnnotationHub)
library(cowplot)
library(ensembldb)

```


## Loading matrices into R

#### - Tutorial: [10X Genomics](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/matrices), [HBC training I](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/03_SC_quality_control-setup.md), [HBC training II](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/readMM_loadData.md)

#### - Package manual: [Matrix](https://cran.r-project.org/web/packages/Matrix/Matrix.pdf)

#### - Read10X() from Seurat package can be used when loading count matrices instead of manual loading. See [HBC training I](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/03_SC_quality_control-setup.md) for more info.

### Preparing annotation

#### - [AnnotationHub Doc](http://bioconductor.org/packages/release/bioc/vignettes/AnnotationHub/inst/doc/AnnotationHub-HOWTO.html)

```{r setup_annotationhub}

# Set species and DB namedb
organism <- "Homo sapiens"
DB <- "EnsDb"   # e.g. EnsDb, OrgDb, etc

# Connect to AnnotationHub
ah <- AnnotationHub(hub=getAnnotationHubOption("URL"))

# Bring the Ensembl DB 
anno.db <- query(ah, 
                 pattern=c(organism, DB), 
                 ignore.case=T)

# Find the id from most recent annotation data
id <- mcols(anno.db) %>% 
    rownames() %>%
    tail(1)

# Download the most recent annotation table 
id.db <- ah[[id]]

# Extract gene-level info and save as a data frame 
gene.db <- genes(id.db, return.type="data.frame")

```

```{r loading_matrix}

# Assign your file paths
barcode.path <- "barcodes.tsv.gz"   # cell ids
features.path <- "features.tsv.gz"  # gene ids
matrix.path <- "matrix.mtx.gz"      # counts

# Import the files
# readMM() turns into a sparse matrix (which only stores non-zero values) 
# in order to minimize data size
mat <- readMM(file=matrix.path) 

feature.names <- read.delim(features.path, 
                            header=FALSE, 
                            stringsAsFactors=FALSE)
barcode.names <- read.delim(barcode.path,
                            header=FALSE,
                            stringsAsFactors=FALSE)


# Assign row/column names
colnames(mat) <- barcode.names$V1
rownames(mat) <- feature.names$V2



```

## Creating a seurat object from the count matrix

#### - Seurat manual: [manual](https://cran.r-project.org/web/packages/Seurat/Seurat.pdf), [Seurat Cheatsheet](https://satijalab.org/seurat/articles/essential_commands.html), [Satija Lab](https://satijalab.org/seurat)

#### - Tutorial reference: [HBC training](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/03_SC_quality_control-setup.md)

#### - "min.features" parameter in CreateSeuratObject() function specifies the minimum number of genes that need to be detected per cell. This argument will filter out poor quality cells that likely just have random barcodes encapsulated without any cell present. Usually, cells with less than 100 genes detected are not considered for analysis. 

#### - CreateSeuratObject() automatically creates metadata as well 

#### - Metadata in the seurat object: orig.ident (this often contains the sample identity if known, but will default to "SeuratProject"), nCount_RNA (number of UNIs per cell), nFeature_RNA (number of genes detected per cell)

```{r create_seurat}

# Create a seurat object 
seurat <- CreateSeuratObject(counts=mat,    # accepts a sparse matrix 
                             min.features=100) # see above note 

# Explore the metadata (see above description)  
head(seurat@meta.data)




# In case you have multiple samples to create a seurat object: 
# 
# for (file in c("ctrl_raw_feature_bc_matrix", "stim_raw_feature_bc_matrix")){
# 
#         seurat_data <- Read10X(data.dir = paste0("data/", file))
#         seurat_obj <- CreateSeuratObject(counts = seurat_data, 
#                                          min.features = 100, 
#                                          project = file)
#         assign(file, seurat_obj)
# }
# 
# Create a merged Seurat object
# merged_seurat <- merge(x = ctrl_raw_feature_bc_matrix, 
#                        y = stim_raw_feature_bc_matrix, 
#                        add.cell.id = c("ctrl", "stim"))
# Check that the merged object has the appropriate sample-specific prefixes
# head(merged_seurat@meta.data)
# tail(merged_seurat@meta.data)

```

## Quality control (QC)

#### - Tutorial: [HBC training](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/04_SC_quality_control.md)

#### - Seurat provides functions for QC shown in this script. For manual QC, consult [this instruction](https://hbctraining.github.io/In-depth-NGS-Data-Analysis-Course/sessionIV/lessons/SC_quality_control_analysis.html)

#### - QC metrics: cell counts, UMI counts per cell, genes detected per cell, UMIs vs genes detected, mitochondrial counts ratio, novelty



### QC: calculating number of genes detected per UMI 

```{r genes_per_UMI}

# Add number of genes per UMI for each cell to metadata
seurat$log10GenesPerUMI <- log10(seurat$nFeature_RNA) / log10(seurat$nCount_RNA)

# Explore the updated metadata
head(seurat@meta.data)
```


### QC: calculating mitochondrial ratio

#### - Proportion of transcripts mapping to mitochondrial genes

#### - Mitochondrial read fractions are only high in particularly low count cells with few detected genes (darker colored data points). This could be indicative of damaged/dying cells whose cytoplasmic mRNA has leaked out through a broken membrane, and thus, only mRNA located in the mitochondria is still conserved.

#### - PercentageFeatureSet() from seurat package searches for any gene identifiers with the patter argument (e.g. "MT-") 

#### - You can manually calculate by following [this tutorial](https://github.com/hbctraining/scRNA-seq/blob/master/lessons/mitoRatio.md) from HBC training in case you can't use the seurat built-in function  

```{r mitochondrial_ratio}

# Compute percent mito ratio
# NOTE: "^MT-" is for human genes. Adjust it depending on your organism of interest.
# Calculate manually as instructed above if you don't have available identifier patterns
seurat$mitoRatio <- PercentageFeatureSet(object=seurat, 
                                         pattern="^MT-")

# Convert the ratio to percentage 
seurat$mitoRatio <- seurat@meta.data$mitoRatio / 100

# Explore the updated metadata
head(seurat@meta.data)

```


### Adding more info to the metadata 

```{r adding_more_info}

# Create a dataframe from the metadata
meta <- seurat@meta.data

# Add cell ids to the data frame
meta$cells <- rownames(meta)

meta <- meta %>% 
    separate(cells, c("Barcode", "Sample"), sep="-")

# Rename some of the columns 
old.colnames <- colnames(meta)
colnames(meta) <- c("seq.folder", "nUMI", "nGene", 
                    old.colnames[4:length(old.colnames)])

# Add Tissue to the data frame
meta$Tissue <- ifelse(meta$Sample %in% c("1", "3", "5"), 
                      "Atherosclerotic Core", 
                      "Proximal Adjacent")

# Explore the updated data frame
head(meta)

# Update the seurat object with the updated metadata
seurat@meta.data <- meta

# Explore the updated metadata
head(seurat@meta.data)


```


### QC: plotting cell counts

#### - cell counts: number of unique barcodes detected 

#### - In theory, the cell counts correspond to the number of cells loaded. However,  it generally ends up being 50-80% of total cells loaded due to capture effieciency which is 70-80% in inDrops and 50-60% in 10X


```{r number_of_cells}

# Plot the number of cells per sample
ggplot(meta, aes(x=Sample, fill=Tissue)) + 
    geom_bar() + 
    theme_bw() + 
    ggtitle("QC: Number of Cells per Sample") + 
    ylab("Number")


```

### QC: plotting UMI counts (transcripts) per cell

#### - UMI counts per cell should be above 500 (denoted by the black dashed line)


```{r umi_per_cell}

# Plot the number of transcripts per cell
ggplot(meta, aes(x=nUMI, fill=Sample, color=Sample)) + 
    geom_density(alpha=0.2) + 
    facet_grid(~Tissue) + 
    scale_x_log10() + 
    theme_bw() +
    theme(strip.text.x=element_text(size=10)) + 
    ggtitle("QC: UMI Counts (Transcripts) per Cell") + 
    ylab("log10 Cell Density") + 
    geom_vline(xintercept=500, linetype="dashed")



```


### QC: number of genes detected per cell

#### - A single large peak: high quality data

#### - Peaks with shoulders or bimodal distribution: failed cells, biologically different types of cells (e.g. quiescent cells, low complexity cells like RBC, etc), and/or variety in cell size

```{r number_of_genes_per_cell}

# Plot the number of genes detected per cell
ggplot(meta, aes(x=nGene, color=Sample, fill=Sample)) + 
    geom_density(alpha=0.2) + 
    facet_grid(~Tissue) + 
    scale_x_log10() + 
    theme_bw() +
    ylab("log10 Cell Density") + 
    theme(strip.text.x=element_text(size=10)) + 
    ggtitle("QC: Number of Genes Detected per Cell") + 
    geom_vline(xintercept=300, linetype="dashed")


ggplot(meta, aes(x=Sample, y=nGene, fill=Tissue)) + 
    geom_boxplot(outlier.alpha=0.5) + 
    theme_bw() + 
    scale_y_log10() + 
    ylab("log10 Number of Genes") + 
    ggtitle("QC: NCells vs NGenes")

```


### QC: nUMIs vs nGenes per cell  

#### - Mitochondrial read fractions are only high in particularly low count cells with few detected genes (darker colored data points). This could be indicative of damaged/dying cells whose cytoplasmic mRNA has leaked out through a broken membrane, and thus, only mRNA located in the mitochondria is still conserved. These cells are filtered out by our count and gene number thresholds. Jointly visualizing the count and gene thresholds shows the joint filtering effect

#### - Cells that are poor quality are likely to have low genes and UMIs per cell, and correspond to the data points in the bottom left quadrant of the plot. Good cells will generally exhibit both higher number of genes per cell and higher numbers of UMIs

#### - With this plot we also evaluate the slope of the line, and any scatter of data points in the bottom right hand quadrant of the plot. These cells have a high number of UMIs but only a few number of genes. These could be dying cells, but also could represent a population of a low complexity celltype (i.e red blood cells)


```{r nUMI_nGenes, fig.width=12, fig.height=8}

# Plot nUMIs vs nGenes per cell along with mitoRatio
ggplot(meta, aes(x=nUMI, y=nGene, color=mitoRatio)) + 
    geom_point(alpha=0.5) + 
    scale_color_gradient(low="gray90", high="black") + 
    geom_smooth(method="lm", color="blue", se=F) +
    facet_grid(Tissue~Sample) + 
    theme_bw() + 
    theme(strip.text.x=element_text(size=10)) + 
    geom_vline(xintercept=500, color="red") + 
    geom_hline(yintercept=250, color="red") + 
    xlab("Number of UMIs per Cell") + 
    ylab("Number of Genes per Cell") + 
    ggtitle("Number of UMIs vs Genes per Cell")

```


### QC: mitochondrial counts ratio 

#### - Mitochondrial contamination is observed in dead or dying cells 

#### - **mitoRatio > 0.2** suggests poor quality 


```{r mitochondrial_contamination}

# Plot proportion of mitochondrial counts 
ggplot(meta, aes(x=mitoRatio, color=Sample, fill=Sample)) + 
    geom_density(alpha=0.2) + 
    theme_bw() + 
    scale_x_log10() + 
    geom_vline(xintercept=0.2) + 
    xlab("Proportion of Mitochondrial Counts Detected") + 
    ylab("Cell Density") + 
    ggtitle("QC: Proportion of Mitochondrial Counts")

```


### QC: complexity

#### - Novelty score: gene diversity per UMI

#### - Ideal **novelty score: > 0.8**

#### - Sometimes we can detect contamination with low complexity cell types like red blood cells via this metric


```{r novelty}

# Plot the overall complexity of the gene expression by visualizing the genes detected per UMI
ggplot(meta, aes(x=log10GenesPerUMI, color=Sample, fill=Sample)) + 
    geom_density(alpha=0.2) + 
    theme_bw() + 
    facet_grid(~Tissue) + 
    theme(strip.text.x=element_text(size=10)) + 
    geom_vline(xintercept=0.8, linetype="dashed") + 
    ggtitle("QC: Complexity of Gene Expression") + 
    ylab("log10 Cell Density")

```


### QC: cell-level filtering

#### - Removes low quality cells 

#### - Thresholds: **nUMI >= 500, nGene >= 250, log10GenesPerUMI >= 0.8, mitoRatio (%) <= 0.2**

#### - Will use subset() function

```{r cell_level_filtering}

# Filter out low quality cells 
f.seurat <- subset(x=seurat, 
                   subset=(nUMI >= 500) & 
                       (nGene >= 250) & 
                       (log10GenesPerUMI > 0.8) & 
                       (mitoRatio < 0.2))

# Compare seurat objects before and after cell-level filtering
seurat     # Before filtering 
f.seurat   # After cell-level filtering
```

### QC: gene-level filtering

#### - Removes low count genes


```{r gene_level_filtering}

# Assign the minimum counts (User-defined!)
count.threshold <- 10

# Extract counts (turns into a parse matrix)
counts <- GetAssayData(object=f.seurat, slot="counts")

# Create a logical matrix identifying non-zero count genes
nonzero <- counts > 0

# Create a logical vector identifying genes with counts over threshold
keep <- rowSums(nonzero) >= count.threshold

# Filter genes with the logical vector 
counts <- counts[keep,]

# Create a new seurat object with the filtered count matrix 
f.seurat <- CreateSeuratObject(counts, 
                               meta.data=f.seurat@meta.data)


# Compare the seurat objects before and after filtering
seurat     # Before filtering
f.seurat   # After cell- and gene-level filtering

```

### QC: QC metrics after filtering


```{r QC_after_filtering, fig.height=8, fig.width=12}

# Extract metadata after filtering
new.meta <- f.seurat@meta.data

# Add a column assigning before or after filtering
meta$Filtering <- "Before Filtering"
new.meta$Filtering <- "After Filtering"

# Remove duplicated columns
new.meta <- new.meta[, colnames(new.meta) %in% colnames(meta)]

# Combine the metadata before and after filtering
both.meta <- rbind(meta, new.meta)

both.meta$Filtering <- factor(both.meta$Filtering, 
                              levels=c("Before Filtering", "After Filtering"))

# Create a bar plot comparing number of cells per sample before and after filtering
ggplot(both.meta, aes(x=Sample, fill=Tissue)) + 
    geom_bar() + 
    facet_grid(~Filtering) +
    theme_bw() + 
    theme(strip.text.x=element_text(size=10)) + 
    ggtitle("QC: Number of Cells per Sample (before & after Filtering)") + 
    ylab("Number") 


# Plot the number of transcripts per cell before and after filtering
ggplot(both.meta, aes(x=nUMI, fill=Sample, color=Sample)) + 
    geom_density(alpha=0.2) + 
    scale_x_log10() + 
    theme_bw() +
    facet_grid(Tissue~Filtering) + 
    theme(strip.text.x=element_text(size=10)) + 
    ggtitle("QC: UMI Counts (Transcripts) per Cell (before & after Filtering)") + 
    ylab("log10 Cell Density") + 
    geom_vline(xintercept=500, linetype="dashed")


# Plot the number of genes detected per cell before and after filtering
# Density plot
ggplot(both.meta, aes(x=nGene, color=Sample, fill=Sample)) + 
    geom_density(alpha=0.2) + 
    scale_x_log10() + 
    theme_bw() +
    facet_grid(~Filtering) + 
    theme(strip.text.x=element_text(size=10)) + 
    ylab("log10 Cell Density") + 
    ggtitle("QC: Number of Genes Detected per Cell (before & after Filtering)") + 
    geom_vline(xintercept=300, linetype="dashed")

# Box plot
ggplot(both.meta, aes(x=Sample, y=nGene, fill=Tissue)) + 
    geom_boxplot(outlier.alpha=0.5) + 
    theme_bw() + 
    facet_grid(~Filtering) + 
    theme(strip.text.x=element_text(size=10)) + 
    scale_y_log10() + 
    ylab("log10 Number of Genes") + 
    ggtitle("QC: NCells vs NGenes (before and after Filtering)")


# Plot nUMIs vs nGenes per cell along with mitoRatio (before and after filtering)
ggplot(both.meta, aes(x=nUMI, y=nGene, color=mitoRatio)) + 
    geom_point(alpha=0.5) + 
    scale_color_gradient(low="gray90", high="black") + 
    geom_smooth(method="lm", color="blue", se=F) +
    facet_grid(Tissue~Filtering) + 
    theme_bw() + 
    theme(strip.text=element_text(size=10)) + 
    geom_vline(xintercept=500, color="red") + 
    geom_hline(yintercept=250, color="red") + 
    xlab("Number of UMIs per Cell") + 
    ylab("Number of Genes per Cell") + 
    ggtitle("Number of UMIs vs Genes per Cell (before & after Filtering)")

# NOTE: Given the fact that this raw data already had mitoRatio close to 0, mitoRatio comparison is skipped

# Plot the overall complexity of the gene expression by visualizing the genes detected per UMI (before and after filtering)
ggplot(both.meta, aes(x=log10GenesPerUMI, color=Sample, fill=Sample)) + 
    geom_density(alpha=0.2) + 
    theme_bw() + 
    facet_grid(Tissue~Filtering) + 
    theme(strip.text.x=element_text(size=10)) + 
    geom_vline(xintercept=0.8, linetype="dashed") + 
    ggtitle("QC: Complexity of Gene Expression (before and after Filtering)") + 
    ylab("log10 Cell Density")
```




## Investigation of unwanted variations and Normalization

#### - Reference: [HBC training I](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/05_normalization_and_PCA.md), [HBC training II](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/06_SC_SCT_normalization.md), [HBC training III](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/cell_cycle_scoring.md), [Seurat "Cell-cycle scoring and regression"](https://satijalab.org/seurat/v3.0/cell_cycle_vignette.html)

#### - Factors being normalized: sequencing depth, gene length 

#### - Identifies the most variant genes

#### - Requires users to know cell types to be present (e.g. low complexity? higher mitochondrial contents? differentiating cells? etc) and to regress out nUMIs, mitochondrial content, and cell cycle if needed 

#### - Seurat provides **sctransform** which simultaneously performs variance stabilization and regresses out unwanted variation 

#### - Roughly normalizes by dividing by total counts per cell and taking the natural log 

#### - Simple linear regression will be performed to correct data after finding the unwanted variation



### Unwanted variation: cell cycle 

#### - **Human cell cycle markers** used in this analysis was obtained from [one](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/06_SC_SCT_normalization.md) of the HBC training courses. If you need the cell cycle markers from other species, check [this](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/cell_cycle_scoring.md) out




```{r importing_cellcycle_genes}

# NOTE: This chunk has to be written by users!!! 
#
#
#
# Import a dataset storing cell cycle genes
cc.genes <- read_csv("https://raw.githubusercontent.com/hbc/tinyatlas/master/cell_cycle/Homo_sapiens.csv")



```



```{r sgenes_g2mgenes}

# Combine two data frames
cc.genes <- inner_join(cc.genes, gene.db, by=c("geneID"="gene_id"))


# Create a vector storing S phase genes
s.genes <- unique(subset(cc.genes, phase=="S")$gene_name)

# Create a vector storing G2M phase genes
g2m.genes <- unique(subset(cc.genes, phase=="G2/M")$gene_name)

# Explore the outputs
head(s.genes)
length(s.genes)
head(g2m.genes)
length(g2m.genes)
```


```{r cellcycle_test}

# Normalize the counts
ccycle.seurat <- NormalizeData(f.seurat)


# Calculate cell cycle scores using CellCycleScoreing() function
ccycle.seurat <- CellCycleScoring(ccycle.seurat, 
                                  g2m.features=g2m.genes,
                                  s.features=s.genes)

# Explore the updated metadata
head(ccycle.seurat@meta.data)

# Examine variation from cell cycle
if ("Phase" %in% colnames(ccycle.seurat@meta.data)) {


# Identify the most variable genes
ccycle.seurat <- FindVariableFeatures(ccycle.seurat,
                                      selection.method="vst",
                                      nfeatures=2000,
                                      verbose=T)

# Scale the data (to mean = 0, variance = 1)
ccycle.seurat <- ScaleData(ccycle.seurat)

# Run PCA
ccycle.seurat <- RunPCA(ccycle.seurat)

# Plot the PCA result
DimPlot(ccycle.seurat, 
        reduction="pca", 
        group.by="Phase", 
        split.by="Phase")

} else { 

    print("No cell cycle effects were found")

}


```

### Unwanted variation: mitochondrial expression

#### - NOTE: In case mitochondrial expression is involved in biological events of your interest, do not correct it


### Normalization and regressing out unwated variation with SCTransform

#### - SCTransform: more accurate method of normalizing, estimating the variance of the raw filtered data, and identifying the most variable genes 

#### - SCTransform uses a regularized negative binomial model 


```{r example_sctransform}

# Run below in case your dataset has variations to regress out and a single group/condition
# ccycle.seurat <- SCTransform(ccycle.seurat, 
#                              vars.to.regress=c("mitoRatio"))

```


## Integration across the conditions by Seurat (optional)

#### - References: [Seurat tutorial I (stim. vs ctrl)](https://satijalab.org/seurat/v3.0/immune_alignment.html), [Seurat tutorial II (cell cycle)](https://satijalab.org/seurat/v3.2/cell_cycle_vignette.html), [Seurat tutorial III (integration)](https://satijalab.org/seurat/v3.2/integration.html), [HBC training](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/postQC_workflow.md), [Stuart and Butler et al, 2018](https://www.biorxiv.org/content/10.1101/460147v1)

### - SCTransformation: models the UMI counts using a regularized negative binomial model to remove the variation based on pooling information across genes with similar abundances (similar to bulk RNA-seq)


```{r split_sctransform}

# Set a condition to split
Condition <- "Tissue" 

# Split the filtered seurat object by condition
split.seurat <- SplitObject(f.seurat, split.by=Condition)


options(future.globals.maxSize=4000 * 1024^2)



# Iterately run NormalizeData(), CellCycleScoring(), and SCTransform()
for (i in 1:length(split.seurat)) { 

    # Normalize
    split.seurat[[i]] <- NormalizeData(split.seurat[[i]], verbose=T) 

    # Score cells for cell cycle
    split.seurat[[i]] <- CellCycleScoring(split.seurat[[i]], 
                                          g2m.features=g2m.genes, 
                                          s.features=s.genes) 

    # Perform SCTransformation: will rank the genes by residual variance and output
    # the 3000 most variant genes by default. 
    # Set a higher value than 3000 to variable.features.n if your dataset is 
    # extra-large. 
    split.seurat[[i]] <- SCTransform(split.seurat[[i]], 
                                     vars.to.regress=c("mitoRatio", 
                                                       "S.Score", 
                                                       "G2M.Score"))
}




```

### Integration

#### - After running IntegrateData, the Seurat object will contain a new Assay with the integrated expression matrix. Note that the original (uncorrected values) are still stored in the object in the "RNA" assay, so you can switch back and forth.h

#### - Integration process: Canonical correlation analysis (CCA, identifying shared cources of variation between the groups/conditions), Identifying anchors (identifying mutual nearest neighbors across the conditions), Filtering anchors (accessing similarity between anchor pairs) 




```{r integration}

# Select the most variable features to use for integration
i.features <- SelectIntegrationFeatures(object.list=split.seurat,
                                        anchor.nfeatures=2000) # 2000 is default

# Prepare the SCT list object for integration
split.seurat <- PrepSCTIntegration(object.list=split.seurat, 
                                   anchor.features=i.features)

# Find anchors (takes time)
anchors <- FindIntegrationAnchors(object.list=split.seurat, 
                                  normalization.method="SCT",
                                  anchor.features=i.features)

# Integrate
integ.seurat <- IntegrateData(anchorset=anchors, 
                              normalization.method="SCT")

```

### Visualization

```{r integration_PCA, fig.width=12, fig.height=8}

# Set default assay to the integrated assay 
DefaultAssay(integ.seurat) <- "integrated" 

# Scale the integrated data
integ.seurat <- ScaleData(integ.seurat) 


# Run PCA
integ.seurat <- RunPCA(integ.seurat)


# Present PCA
pca.1 <- DimPlot(integ.seurat, 
                 reduction="pca", 
                 group.by=Condition) + 
        ggtitle(paste("PCA by", Condition))

pca.2 <- DimPlot(integ.seurat, 
                 reduction="pca", 
                 group.by=Condition, 
                 split.by=Condition) + 
        ggtitle(paste("PCA by", Condition))

pca.1 + pca.2

```

```{r integration_UMAP, fig.width=12, fig.height=8}

# Run UMAP
integ.seurat <- RunUMAP(integ.seurat, dims=1:30, reduction="pca")

# Present UMAP
umap.1 <- DimPlot(integ.seurat, 
                  reduction="umap",
                  group.by=Condition) + ggtitle(paste("UMAP by", Condition)) 

umap.2 <- DimPlot(integ.seurat,
                  reduction="umap", group.by=Condition, 
                  split.by=Condition) + ggtitle(paste("UMAP by", Condition))


umap.1 + umap.2 

```

## Clustering 

#### - References: [Seurat tutorial](https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html), [HBC training](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/07_SC_clustering_cells_SCT.md)

#### - Seurat clusters cells based on their PCA scores, with each PC essentially representing a 'metafeature' that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. However, how many componenets should we choose to include? 10? 20? 100?

### Determining the 'demensionality' of the dataset 

#### - JackStraw prodedure: Seurat implemented a resampling test inspired by the JackStraw procedure. It randomly permuted a subset of the data (1% by default) and rerun PCA, constructing a 'null distribution' of feature scores, and repeat this procedure. It then identified 'significant' PCs as those who have a strong enrichment of low p-value features. However, this technique takes long time to run. So other approaches are more recommended for big datasets.'Significant' PCs will show a strong enrichment of features with low p-values (solid curve above the dashed line). In this case it appears that there is a sharp drop-off in significance after the first 10-12 PCs.




```{r JackStraw}

#### TEMPORARILY NOT EXECUTABLE DUE TO COMPATIBILITY ISSUES IN SEURAT 4.0.0 ####

# integ.seurat <- JackStraw(integ.seurat, num.replicate=100)
# integ.seurat <- ScoreJackStraw(integ.seurat, dims=1:20)
# JackStrawPlot(integ.seurat, dims=1:20)

```

#### - Elbow plot: a ranking of principle components based on the percentage of variance explained by each one (ElbowPlot function)


```{r elbow_plot}

ElbowPlot(integ.seurat, ndims=50)

```


#### - Heatmap by PC: The idea is that we are looking for a PC where the heatmap starts to look more "fuzzy", i.e. where the distinctions between the groups of genes is not so distinct. However, it's a subjective way in determining the "elbow". 

```{r PC_heatmap}

DimHeatmap(integ.seurat, 
           dims=1:15, 
           cells=500, 
           balanced=T)

print(integ.seurat[["pca"]],
      dims=1:15, 
      nfeatures=5)

# Based on the elbow plot and heatmap, 14 dims will be used for clustering 
# in the next section! 
```

### Clustering 

#### - Seurat provides a graph-based clustering using K-nearest neighbor (KNN) by defaut. 

#### - In the **FindClusters()** function, the argument **"resolution"** is used to determine granularity. Higher values result in more clusters. In case of a dataset of 3000-5000 cells, test the resolution between 0.4 and 1.4 before deciding the best resolution setting.

#### - Clustering by resolution is visualized by dim reduction plot such as UMAP and tSNE.  

```{r clustering, fig.height=8, fig.width=12}

# Find neighbors using KNN 
integ.seurat <- FindNeighbors(integ.seurat, dims=1:13)



# Explore the clustering outputs
head(integ.seurat@meta.data)

# Create a vector storing your resolutions of interest
r.vector <- c(0.4, 0.8, 1.2)

# Set a function to visualize the clustering in each resolution setting
create.umap.fn <- function(obj, resol, split) {

    # Find clusters 
    obj <- FindClusters(obj, resolution=resol)

    # Assign the identity of the clustering (resolution=resol)
    Idents(obj) <- paste0("integrated_snn_res.", as.character(resol))

    # Visualize with a umap
    DimPlot(obj, 
            reduction="umap", 
            label=T, 
            split.by=split, 
            label.size=5) + ggtitle(paste("UMAP by", split, "with Clustering")) 
}
 
# Test clustering  
create.umap.fn(integ.seurat, r.vector[1], Condition)
create.umap.fn(integ.seurat, r.vector[2], Condition)
create.umap.fn(integ.seurat, r.vector[3], Condition)

# Determine your optimal resolution
final.resol <- r.vector[1]    # Manually set

# Assign clusters to the seurat object
integ.seurat <- FindClusters(integ.seurat, resolution=final.resol)
Idents(integ.seurat) <- paste0("integrated_snn_res.", as.character(final.resol))
head(integ.seurat@meta.data)

# Create a vector storing the cluster numbers
cl.vector <- as.numeric(unique(integ.seurat@meta.data$seurat_clusters)) - 1


```


## Clustering quality control

#### - References: [HBC training](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/08_SC_clustering_quality_control.md), [Seurat tutorial](https://satijalab.org/seurat/vignettes.html)

### Exploration of QC metrics

#### - Examines whether the clusters might be due to artifacts such as cell cycle phase or mitochondrial expression

#### - Data extraction from a seurat object uses the FetchData() function. Other ways are summarized in the seurat [cheatsheet](https://satijalab.org/seurat/articles/essential_commands.html) 

#### - Segregation of clusters by sample

```{r segregation_by_sample}

# Extract the number of cells per cluster
nc <- FetchData(integ.seurat,
                # "ident": cluster 
                # Condition: experimental group (e.g. Tissue, Treatment, Genotype, etc)
                vars=c("ident", Condition)) %>% group_by(ident, Tissue) %>% count() 

# Plot the number of cells per cluster
nc %>% 
ggplot(aes(x=ident, y=n, fill=ident)) + 
geom_bar(stat="identity") + 
facet_grid(~Tissue) + 
theme_bw() + 
theme(strip.text.x=element_text(size=10),
      legend.title=element_blank()) + 
ggtitle("Number of Cells per Cluster") + 
ylab("Number of Cells") + 
xlab("Cluster")

# Plot the proportion of cells per cluster
nc %>% 
ggplot(aes(x=Tissue, y=n, fill=ident)) + 
geom_bar(stat="identity", color="black", position="fill") + 
theme_bw() + 
theme(legend.title=element_blank()) + 
ggtitle("Proportion of Cells per Cluster") + 
ylab("Proportion") 

 

```

#### - Segregation of clusters by cell cycle phase

```{r segregation_by_cellcycle, fig.width=12}


DimPlot(integ.seurat, 
        label=T, 
        split.by="Phase") + NoLegend()

```


#### - Segregation of clusters by other metrics

```{r segregation_by_othersources, fig.width=12}

# Set a function creating a feature plot
# 
# order: positive cells above negative cells
# min.cutoff: threshold of shading. 'q10' indicates the bottom 10% of the cells will be colored completely grey 
featurepl.fn <- function(options) {

    FeaturePlot(integ.seurat, 
            reduction="umap", 
            order=T,
            features=options,
            min.cutoff="q10", 
            label=T) 
}

# Determine metrics of potential sources of variation 
# (e.g. mitoRatio, S.Score, G2M.Score, etc) 
other.sources <- c("nUMI", "nGene") 

# Plot the sources along with clusters 
featurepl.fn(other.sources)
```


#### Exploration of the PCs driving the different clusters 


```{r explore_PCs}

# Define a vector storing variables to extract from the seurat object
clm <- c(paste0("PC_", 1:14), 
         "ident", 
         "UMAP_1", 
         "UMAP_2") 

# Extract and save as a data frame 
pcs <- FetchData(integ.seurat, vars=clm) %>% 
    group_by(ident) %>%
    gather("PC", "Score", starts_with("PC")) 

# Explore the output
head(pcs)

# Create a data frame storing center locations of each cluster 
umap.center <- pcs %>% 
    group_by(ident) %>% 
    summarize(x=mean(UMAP_1), y=mean(UMAP_2))

# Explore the output 
head(umap.center)

# Convert the character variable PC to factor
pcs$PC <- factor(pcs$PC, levels=paste0("PC_", 1:15))

# Plot the PC scores by cluster
ggplot(pcs, aes(x=UMAP_1, y=UMAP_2)) + 
    geom_point(alpha=0.2, aes(color=Score)) + 
    facet_wrap(~PC) + 
    theme_bw() + 
    scale_color_gradient(guide=F, low="grey90", high="blue") + 
    geom_text(data=umap.center,  
              aes(label=ident, x=x, y=y)) + 
theme(strip.text.x=element_text(size=10)) + 
ggtitle("PC Scores by Cluster")

# Extract 10 most significant genes in the PC 1 and 2
print(integ.seurat[["pca"]], dims=1:5, nfeatures=10)
```

### Exploring known cell type markers

#### - Normalized count data is stored in the **RNA assay** slot. So it is required to reset the default assay to the RNA assay. 

#### - Know what marker genes you are interested in to identify the cell types in the given clustering. 

#### - References: [Sulkava et al., 2017](https://www.nature.com/articles/srep41483)


```{r explore_markers}


# Reset the default assay to "RNA"
DefaultAssay(integ.seurat) <- "RNA"

# Renormalize the data 
integ.seurat <- NormalizeData(integ.seurat)

# Explore endothelial cell markers
# ENSG00000261371: CD31 (PECAM1)
# ENSG00000090339: ICAM1
ec.genes <- c("PECAM1", "ICAM1")
featurepl.fn(ec.genes)

# Explore smooth muscle cell markers 
# ENSG00000107796: ACTA2
# ENSG00000133392: MYH11 (SMMHC)
smc.genes <- c("ACTA2", "MYH11")
featurepl.fn(smc.genes)

# Explore T cell markers
# ENSG00000110848: CD69 (early marker)
# ENSG00000010610: CD4
# ENSG00000153563: CD8
t.genes <- c("CD69", 
             "CD4", 
             "CD8A")
featurepl.fn(t.genes)

# Explore B cell markers
# ENSG00000177455: CD19 
# ENSG00000081237: B220 (PTPRC)
b.genes <- c("CD19", "PTPRC")
featurepl.fn(b.genes)


# Explore macrophage markers
# ENSG00000121594: CD36
# ENSG00000114013: CD86 
# ENSG00000129226: CD68
m.genes <- c("CD36", "CD86", "CD68")
featurepl.fn(m.genes)
```

## Marker identification

#### - Reference: [HBC training](https://github.com/hbctraining/scRNA-seq_online/blob/master/lessons/09_merged_SC_marker_identification.md)

#### - Top markers are trustworthy since p-values are inflated. 

#### - Approaches: identification of all markers for each cluster, identification of conserved markers for each cluster, marker identification between specific clusters 




### Identification of all markers in all conditions 

#### - Is used when evaluating a single group/condition 

#### - FindAllMarkers() function compares each cluster against all other cluster 

#### - The cells in each cluster are treated as replicates 

#### - The default is Wilcoxon Rank Sum test with extra options 

#### - Outputs DEGs 

#### - Is useful for identifying unknown clusters and improving confidence in hypothesized cell types 


```{r all_markers}

# Run only if your dataset has a single group/condition
# markers <- FindAllMarkers(integ.seurat, only.pos=T, logfc.threshold=0.25) 
#
# only.pos: keeps only positive changes 
#
# logfc.threshold: min log2 foldchange for mean expression in this cluster vs other clusters. Default is 0.25
#
# min.diff.pct: min percent difference in cell population expressing the gene in this cluster vs all other clusters combined 
#
# min.pct: min fraction of cell population expressing the gene in either of the clusters

```


### Identification of conserved markers for each cluster

#### - Looks for DEGs in each cluster first 

#### - Outputs the DEGs that are conserved in the cluster across all conditions 

#### - Is useful with more than one condition to identify cell type markers that are conserved across conditions 

#### - This step requires "multtest" (Bioconductor) and "metap" (CRAN) packages installed 


```{r conserved_markers}

# Reset default assays to "RNA" 
DefaultAssay(integ.seurat) <- "RNA"

# Renormalize the data 
integ.seurat <- NormalizeData(integ.seurat)

# Explore the clusters by Condition 
cluster.stat <- table(integ.seurat@meta.data$seurat_clusters, 
                      integ.seurat@meta.data$Tissue) %>% as.data.frame() 
names(cluster.stat) <- c("Cluster", Condition, "N")
head(cluster.stat)

# Extract cluster numbers having zero cells 
cluster.stat.zero <- subset(cluster.stat, N == 0)$Cluster




# Set a function finding conserved markers and converting the output to a data frame 
find.cmarkers.fn <- function(obj, cluster) {

    

    marker.output <- FindConservedMarkers(obj, 
                                          ident.1=cluster, 
                                          grouping.var=Condition, 
                                          only.pos=T, 
                                          logfc.threshold=0.25) %>% 
    rownames_to_column("Gene") %>%
    as.data.frame() %>% 
    mutate(Cluster=cluster)

}





# Find conserved markers in the cluster 0
cmarkers.df <- find.cmarkers.fn(integ.seurat, 0)
dim(cmarkers.df)
head(cmarkers.df)

# Find conserved markers in the rest of the clusters iteratively
# NOTE: skip clusters having zero cells!! 
i <- 1
while (i <= max(cl.vector)) {

    if (i %in% cluster.stat.zero) {

        i <- i + 1

    } else { 

        rest.df <- find.cmarkers.fn(integ.seurat, i) 

        cmarkers.df <- rbind(cmarkers.df, rest.df)

        i <- i + 1

    }


}

# Explore the updated conserved markers data frame 
dim(cmarkers.df)
head(cmarkers.df)


# Remove spaces in the column names
column.names <- colnames(cmarkers.df)
column.names <- str_replace(column.names, " ", "_") 
names(cmarkers.df) <- column.names
head(cmarkers.df)

# Create a vector storing mean log2FC across the conditions 
log2FC.columns <- column.names[str_detect(column.names, "log2FC")]
mean.log2FC <- rowMeans(cmarkers.df[, log2FC.columns]) 

# Combine the calculated mean log2FC with the conserved marker data frame
cmarkers.df <- cbind(cmarkers.df, mean_log2FC = mean.log2FC)

# Extract top 10 conserved markers by cluster
top.cmarkers <- cmarkers.df %>%
    group_by(Cluster) %>% 
    top_n(n=10, wt=mean_log2FC) 

head(top.cmarkers)


```

```{r visualize_conserved_markers, fig.width=12, fig.height=8}

# Visualize cells the top 10 genes using featurepl.fn by cluster
top.cmarkers <- top.cmarkers %>% 
    group_by(Cluster) %>% 
    nest() %>% 
    mutate(feature_plot=map(data, ~ featurepl.fn(.x$Gene)))

for (j in top.cmarkers$Cluster) { 

    df1 <- subset(top.cmarkers, Cluster == j)

    df2 <- df1 %>% unnest(data)

    print(paste0("Cluster ", j, ":"))
    print(df2$Gene)
    print(df1$feature_plot)


}


```

### Renaming clusters 

#### - Has to be conducted manually after confirming clusters' identity based on the conserved marker genes


```{r assign_celltype, fig.width=12, fig.height=8}

# Re-assign cell identity
integ.seurat <- RenameIdents(integ.seurat,
                             "0"="CTL/NK I", 
                             "1"="T",
                             "2"="Fibroblast", 
                             "3"="EC",
                             "4"="DC/Macrophage", 
                             "5"="SMC", 
                             "6"="Macrophage",
                             "7"="Neutrophil/Monocyte", 
                             "8"="CTL/NK II",
                             "9"="EC",
                             "10"="B",
                             "11"="Unclassified", 
                             "12"="Mast cell/Basophil",
                             "13"="Proliferating", 
                             "14"="Unclassified")

# Plot the UMAP with the cell types
DimPlot(integ.seurat, 
        reduction="umap",
        label=T,
        label.size=5,
        repel=T) + ggtitle("Cell Type")



```

## Saving the Seurat object and the session info


```{r saving_myobject}

# Save the R object
write_rds(integ.seurat, "integ.seurat_label_v1.1.rds")

# Create a text filing storing my session info
sink("sessionInfo_scRNAseq_v1.txt")
sessionInfo()
sink()


```


